<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>404Found</title>
  
  <subtitle>瞅啥啥不会，做啥啥不对</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-16T10:08:06.929Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>把星子放入眸</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试中的操作系统-进程与线程</title>
    <link href="http://yoursite.com/2020/03/16/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/16/面试中的操作系统-进程与线程/</id>
    <published>2020-03-16T09:51:42.000Z</published>
    <updated>2020-03-16T10:08:06.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试中的操作系统之进程、线程和协程"><a href="#面试中的操作系统之进程、线程和协程" class="headerlink" title="面试中的操作系统之进程、线程和协程"></a>面试中的操作系统之进程、线程和协程</h1><h3 id="线程与进程的定义"><a href="#线程与进程的定义" class="headerlink" title="线程与进程的定义"></a>线程与进程的定义</h3><p><strong>进程是操作系统分配资源和调度的最小单位，是独立功能的程序在特定数据集合上的一次执行过程。线程是调度的基本单位，一个进程内可以有多个线程，共享进程的资源。</strong></p><blockquote><p>在linux下，进程的创建由fork实现。当fork函数被调用时，新创建的进程会完全拷贝父进程的资源和数据。fork调用结束后，父进程和子进程独立运行互不影响。<br>线程一般由pthread_create创建。同一个进程下可以创建多个线程，他们共享进程拥有的资源和数据，因此存在竞争的风险。因此多线程访问共享资源时，需要有同步措施以保证数据安全。线&gt; 程的生命周期跟父进程的生命周期有关，如果父进程退出，那么他所创建的所有线程都会退出。</p></blockquote><h3 id="进程-线程间通信方式"><a href="#进程-线程间通信方式" class="headerlink" title="进程/线程间通信方式"></a>进程/线程间通信方式</h3><ol><li>进程间常用的通信方式有：<br> 共享内存、消息队列、信号量、有名管道、无名管道、信号、文件、socket<ol><li>线程间通信方式，除进程间通信方式之外，还有：<br> 互斥量、锁</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试中的操作系统之进程、线程和协程&quot;&gt;&lt;a href=&quot;#面试中的操作系统之进程、线程和协程&quot; class=&quot;headerlink&quot; title=&quot;面试中的操作系统之进程、线程和协程&quot;&gt;&lt;/a&gt;面试中的操作系统之进程、线程和协程&lt;/h1&gt;&lt;h3 id=&quot;线程与进程
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程与线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试中的计算机网络之TCP的可靠传输</title>
    <link href="http://yoursite.com/2020/01/30/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BTCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2020/01/30/面试中的计算机网络之TCP的可靠传输/</id>
    <published>2020-01-30T04:17:33.000Z</published>
    <updated>2020-01-30T04:17:33.437Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试中的计算机网络之三次握手四次断开</title>
    <link href="http://yoursite.com/2020/01/29/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%96%AD%E5%BC%80/"/>
    <id>http://yoursite.com/2020/01/29/面试中的计算机网络之三次握手四次断开/</id>
    <published>2020-01-29T12:45:52.000Z</published>
    <updated>2020-01-30T04:15:13.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单整理一下面试过程中遇到的计算机网络问题，方便后面复习。</p></blockquote><h2 id="1-TCP三次握手四次断开的过程简单描述"><a href="#1-TCP三次握手四次断开的过程简单描述" class="headerlink" title="1. TCP三次握手四次断开的过程简单描述"></a>1. TCP三次握手四次断开的过程简单描述</h2><h4 id="三次握手过程："><a href="#三次握手过程：" class="headerlink" title="三次握手过程："></a>三次握手过程：</h4><ol><li>第一次握手。客户端发起握手请求，携带标志SYN=1，序号取随机值seq=i。此时客户端进入SYN_SENT状态，等待服务器回包。</li><li>第二次握手。服务器收到请求回，回复数据包，SYN=1，ACK=1，ack=i+1，seq=j，j也是随机值。此时服务器进入SYN_RECV状态。</li><li>第三次握手。客户端收到服务器回包后，回复ACK=1，ack=j+1。此时客户端跟服务器都进入ESTABLISHED状态。</li></ol><h5 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h5><pre><code>双端第一个数据包时，包中的序号字段seq取值为一个跟时间相关的随机值，RFC793的一种实现是一个32bit的计数器，每4ms加1。ack的含义是下一次期望收到的序号，握手请求本身也会占用一个序号，所以ack=seq+1。正常情况下，ack应该取值为对方seq+包中数据长度。握手过程中，SYN标志位置1，代表本次请求是一个握手请求，ACK标志为置1，表示该请求是一个握手回复。印象中，第三次握手是可以跟正常的数据合并到一起发送的。（待确认）</code></pre><h4 id="四次断开的过程："><a href="#四次断开的过程：" class="headerlink" title="四次断开的过程："></a>四次断开的过程：</h4><ol><li>第一次断开。客户端发送一个FIN=1的数据包，用于中止客户端到服务器的数据通道。此时客户端进入FIN_WAIT_1状态。</li><li>第二次断开。服务器收到客户端的FIN请求之后，回复数据包ACK=1,ack=对方seq+1（FIN请求同样占用一个序号）。此时服务端进入CLOSE_WAIT状态。此时的TCP链接处于半链接状态，客户端已经不能向服务器发送数据，但是服务器依然可以向客户端发送数据。此时客户端处于FIN_WAIT_2状态。</li><li>第三次断开。服务器数据发送完毕后，发送一个FIN给客户端(ACK=1)，关闭服务端到客户端的数据通道。此时服务器进入LAST_ACK状态。</li><li>第四次断开。客户端收到FIN之后，回复ACK=1,ack=对方seq+1，同时进入TIME_WAIT状态。服务器收到最后的ack之后，进入CLOSED状态。</li></ol><h5 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h5><pre><code>TCP是全双工的数据传输通道，所以客户端和服务端可以分别关闭自己的数据传输通道。只有双方都关闭之后，整个链接才算完整的关闭了该链接。</code></pre><h4 id="常见的问题："><a href="#常见的问题：" class="headerlink" title="常见的问题："></a>常见的问题：</h4><ol><li><p>为什么需要三次握手，两次握手为什么不可以？<br> 目的是为了防止已失效的握手数据包到达服务端。网络中存在延迟，客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p></li><li><p>为什么要有TIME_WAIT状态？<br> 在TCP链接释放过程中，首先关闭链接的一段会有TIME_WAIT状态。TIME_WAIT存在的原因主要有以下两点：<br> a. 为了保证TCP链接可靠的释放。在主动关闭方发送最后一个FIN的ack时，如果因为网络原因导致ack没有被对方收到就关闭了俩节。对方重发的FIN请求到达，此时主动关闭方已经进入CLOSED状态，因此会回复RST包。导致对方可能认为此时链接出现了问题，而此时其实链接处于正常关闭的状态。<br> b. 为了保证旧的链接的数据包在网络中彻底消失。TCP链接使用（local_ip，local_port，remote_ip，remote_port）来标志一个唯一链接。假如最后一个FIN因为超时进行了重发后双方正常关闭了了链接，并重新建立了新的链接。如果网络中遗留的上一个链接的FIN数据包到达，有可能导致不可预知的问题。为了避免这种情况，在链接关闭后的TIME_WAIT状态（2MSL的时间）时，此IP端口不会被使用，不会建立新的链接。<br> c. MSL是报文最大生存时间，2MSL的目的是让对方的FIN报文以及自己的ACK报文都能在网络中消失。<br> d. 对处于TIME_WAIT状态的端口建立新的链接时会提示address already in use，为了防止这种情况，可以设置socket的SO_REUSEADDR的选项来避免TIME_WAIT状态。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单整理一下面试过程中遇到的计算机网络问题，方便后面复习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-TCP三次握手四次断开的过程简单描述&quot;&gt;&lt;a href=&quot;#1-TCP三次握手四次断开的过程简单描述&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="面试中的计算机网络" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>2020&#39;s 学习计划</title>
    <link href="http://yoursite.com/2020/01/29/2020&#39;s-%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2020/01/29/2020&#39;s-学习计划/</id>
    <published>2020-01-29T12:40:00.000Z</published>
    <updated>2020-01-29T12:34:36.856Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="规划" scheme="http://yoursite.com/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>必知必会的面试题集合</title>
    <link href="http://yoursite.com/2019/02/27/%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/02/27/必知必会的面试题集合/</id>
    <published>2019-02-27T06:13:47.000Z</published>
    <updated>2019-02-28T02:50:22.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-网络服务如何保证幂等性？"><a href="#1-网络服务如何保证幂等性？" class="headerlink" title="1. 网络服务如何保证幂等性？"></a>1. 网络服务如何保证幂等性？</h3><p>幂等性最初来自于数学上的概念，f(x)=f(f(x)) 。当某个运算为幂等运算时，其作用在任何一个元素两次后跟作用一次的结果相同。在编程领域，幂等性意味着对同一个系统，同样的条件下，一个请求和多个重复的请求对系统资源的影响是一致的。<br>幂等性最常见的例子就是支付，用户购买商品时需要使用在线支付，如果用户支付成功，但返回结果时候网络异常，此时钱已经扣了，但用户没有收到支付成功的提醒。此时如果用户再次点击支付，将进行二次扣款，这样就会导致用户的钱被扣了两次，造成错误。<br>我们的服务有很多操作是天然实现幂等性的，比如查询接口。但对于增加，更新，删除等，如何保证幂等性呢？</p><h5 id="1-全局唯一的ID"><a href="#1-全局唯一的ID" class="headerlink" title="(1). 全局唯一的ID"></a>(1). 全局唯一的ID</h5><p>对于业务的每一次操作都生成一个全局ID，在执行操作前先检查该ID是否已执行过该操作。如果没有则把ID存储，正常执行该操作，如果已存在则表明该操作已经执行。<br>订单支付这个场景就可以使用订单ID作为全局的ID，用于保证服务的幂等性。</p><h5 id="2-去重表"><a href="#2-去重表" class="headerlink" title="(2). 去重表"></a>(2). 去重表</h5><p>利用数据库表的特性来实现幂等性，常用思路是在表上构建一个唯一索引，保证一旦一个操作执行完毕后，后续的操作进行相同的插入操作时没有办法写入成功。<br>例如要防止重复点赞，可以设计一个表，将被点赞内容ID和用户ID建立唯一索引，用户每次点赞就往表中写入一条数据，这样重复点赞的记录没有办法写入，就能实现点赞的幂等性。</p><h5 id="3-MVCC方案"><a href="#3-MVCC方案" class="headerlink" title="(3). MVCC方案"></a>(3). MVCC方案</h5><p>多版本控制，该策略主要使用update with condition来保证多次外部请求调用对于系统的影响是一致的。在系统设计时，合理使用乐观锁，通过版本号来做乐观锁的判断条件，这样即使在并发的情况下，系统也不会有太大的问题。例如：</p><blockquote><p>select * from tablename where condition=#condition# //取出要跟新的对象，带有版本versoin<br>update tableName set name=#name#,version=version+1 where version=#version#</p></blockquote><h5 id="4-状态机"><a href="#4-状态机" class="headerlink" title="(4). 状态机"></a>(4). 状态机</h5><p>这种方法适合在有状态机流转的情况下，比如就会订单的创建和付款，订单的付款肯定是在之前，这时我们可以通过在设计状态字段时，使用int类型，并且通过值类型的大小来做幂等，比如订单的创建为0，付款成功为100,付款失败为99。</p><blockquote><p>update <code>order</code> set status=#{status} where id=#{id} and status&lt;#{status}</p></blockquote><h3 id="2-memcached和redis对比"><a href="#2-memcached和redis对比" class="headerlink" title="2. memcached和redis对比"></a>2. memcached和redis对比</h3><p>memcached和redis都属于内存数据库，在设计上有很多相同之处，功能和应用场合也相似。Redis与memcached最大的不同在于，redis的所有数据不都是一直在内存中。下面从功能，性能和应用场景简单分析一下memcached和redis。</p><h5 id="1-性能"><a href="#1-性能" class="headerlink" title="(1). 性能"></a>(1). 性能</h5><p>redis使用单核，而memcached使用多喝，所以平均每一个核上redis在存储小数据是比memcached性能更高。但在100K以上的数据时，memcached的性能要高于redis。</p><h5 id="2-功能"><a href="#2-功能" class="headerlink" title="(2). 功能"></a>(2). 功能</h5><pre><code>- memcached只支持内存的key-value存储，而redis则可以支持Strings，Lists，Sets，Sorted Set，Hash等多种类型。- memcached数据全放在内存中，不支持存储持久化，因此服务如果挂掉，数据不可恢复，而redis支持数据持久化，提供了snapshotting和AOF两种方式持久化数据到硬盘上，数据丢失后可以恢复。从这点上说，redis更像是一个完整的数据库系统。- memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。redis没有提供cas命令，但因为redis是单进程处理请求，所有的命令串行执行，所以并发情况下不需要考虑一致性问题。同时，redis也提供了事务的能力，可以保证特定操作的原子性。</code></pre><h5 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="(3). 应用场景"></a>(3). 应用场景</h5><pre><code>- 相对于memcached，redis的出现时间更晚且功能更完备，我们通常将其视为首选方案，但在某些特殊场景下，memcached有着显著的优势。一是对于小型静态数据的缓存处理，最具代表性的例子就是缓存HTML片段。memcached的内部内存管理机制相对redis来说更加简单，但也更有效率--这是因为memcached在处理元数据是所消耗的内存资源相对更少。作为memcached唯一支持的一种数据类型，字符串适合保存那些只需要读取的操作，因为字符串本身无需进一步的处理。二是memcached在横向扩展方面相对于redis也更有优势。由于其在设计上的思路倾向以及相对简单的功能设置，memcached在实现扩展是比redis简单的多。- redis几乎在缓存管理中的每一个方面都表现出优于memcached的性能。redis在排行榜，列表，消息订阅，队列等方面都有不错的应用场景，如果需要支持复杂类型，那么redis是你不二的选择（划水）。。。- https://blog.csdn.net/sosfnima/article/details/51993181- https://blog.csdn.net/u011489043/article/details/78922390</code></pre><h3 id="3-mysql性能优化"><a href="#3-mysql性能优化" class="headerlink" title="3. mysql性能优化"></a>3. mysql性能优化</h3><p>谈到Mysql优化，每个人收藏了很多技巧：不要使用SELECT * ，不要使用NULL字段，合理创建索引等等，问题是，你真的理解这些优化技巧背后的原理吗？</p><h5 id="1-Scheme设计与数据类型优化"><a href="#1-Scheme设计与数据类型优化" class="headerlink" title="(1). Scheme设计与数据类型优化"></a>(1). Scheme设计与数据类型优化</h5><p>选择数据类型要遵循小而简单的原则，越小的数据类型通常会更快，占用更少的内存，磁盘，和CPU处理周期。例如整形比字符操作代价第，因而应该使用整型来存储IP地址，使用DATETIME来存储时间，而不是字符串。这里总结几个容易理解错误的几个技巧:</p><pre><code>- 通常来说可以把为NULL的列改成NOT NULL不会对性能提升有很多帮助，只是如果计划在列上做索引，就应该将该列设置为NOT NULL。- 对指数类型指定宽度，比如INT(11)没有任何卵用，INT使用32位存储空间，那么他的表示范围已经确定，INT(1)和INT(20)对于存储和计算都是相同的。- UNSIGNED标识不允许负值，大致上可以使正整数的上线提高一倍，比如TINYINT的存储范围是-128~127，而UNSIGNED TINYINT的存储范围是0~255。- 通常来讲,没有太大的必要使用DECIMAL数据类型。即使需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一万然后使用BIGINT存储，这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。- TIMESTAMP使用4个字节存储，DATETIMNE使用8个字节存储。因为TIMESTAMP只能表示1970-2038年，比DATETIME的表示范围小很多，而且TIMESTAMP的值因时区不同而不同。- 大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串必须使用ALTER TABLE。- schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储层之间通过缓冲格式拷贝数据，然后在服务器层将缓冲数据解码成各个列，这个转换的过程代价很高。如果列太多而实际使用的列很少的话，会导致CPU占用过高。- 大表ALTER TABLE非常耗时，MySQL执行大部分修改结构操作的方法是用新的结构创建一个空表，然后从旧的表中查出所有数据插入到新表，然后删除旧表。尤其当内存不大而表很大，而且还有很大索引的情况下，耗时更久。</code></pre><h5 id="2-创建高性能索引"><a href="#2-创建高性能索引" class="headerlink" title="(2). 创建高性能索引"></a>(2). 创建高性能索引</h5><p>索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要大量的监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定大于初试添加索引的时间。<br>创建索引时，应注意以下几个问题：</p><pre><code>- 非独立的列无法使用索引，例如表达式，函数等等- 如果列很长，可以索引开始的部分字符，这样可以有效减少索引空间，提高索引效率- 多数情况下，多个列上创建索引不能提高查询性能。当多个索引做相交操作时，一个包含所有相关列的索引优于多个独立索引。当多个索引做联合操作时，对结果集的合并、排序等操作要消耗大量的CPU和内存资源，特别是当其中的某些索引选择性不高，需要返回合并大量数据的时候，查询成本更高，这个时候还不如走全表扫描。- 避免多个范围条件。- 覆盖索引。如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就成为覆盖索引。覆盖索引是非常有用的工具，可以极大地提高性能，因为查询只需要扫描索引会带来额外的好处：索引条目小于数据行大小，如果只读取索引，极大减少数据访问量。索引是有按照列增值顺序存储的，对于IO密集型的范围查询要比随机从磁盘读取每一个的数据IO要少的多。- 尽量减少冗余索引，冗余索引是在相同的列上按照相同的顺序创建相同类型的索引。- 删除长时间未使用的索引。</code></pre><h5 id="3-特定类型查询优化"><a href="#3-特定类型查询优化" class="headerlink" title="(3). 特定类型查询优化"></a>(3). 特定类型查询优化</h5><pre><code>- 优化COUNT()查询。COUNT()有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时要求列值是非空的，它不会统计NULL。如果确认括号内表达式不为空时，则就是在统计行数，作用等同于COUNT(**)。这里常常会有个误解，以为COUNT(col)性能更好，但其实这个只是统计了某列非NULL的数量。如果要统计函数，直接使用COUNT(**)就好，意义清晰，且性能更好。在有些场景下业务并不需要精确的COUNT值，此时可以用EXPLAIN来获取一个近似行数。EXPLAIN不需要真正的去执行查询，所以成本非常低。- 优化关联查询。在大量数据的情境下，表与表之间通过一个冗余字段来关联比直接使用JOIN有更好的性能。如果确实需要使用JOIN来进行查询，则需要注意：a. 确保ON和USING的列上有索引; b. 确保任何的GROUP BY和ORDER BY中的表达式只涉及一个表中的列，这样MySQL才会有可能使用索引来优化。- 优化LIMIT分页。需要使用分页操作时，通常使用LIMIT加上便宜来实现，同时加上合适的ORDER BY字段。如果有对应的索引，通常效率不错，否则，MySQL需要做大量的文件排序操作。一个常见的问题是当偏移量非常大的时候，例如LIMIT 10000 20，MySQL需要查询10020条数据并将之前的10000条数据全部丢弃。优化这种查询的方法就是尽可能使用覆盖索引进行扫描，而不是查询所有的列。然后根据需要做一次查询再返回所有的列，对于便宜量非常大是，这样做的效率提升会非常大。考虑下面的例子:&gt;  SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;如果这个表非常的大，那么查询改成下面这样将大幅度提升查询效率:&gt; SELECT film.film_id,film.description FROM film INNER JOIN (SELECT film_id FROM film ORDER BY title LIMIT 50,5) AS tmp USING(film_id);有时候可以记录上次数据读取位置，下次可以直接从该位置开始扫描，这样就可以避免使用OFFSET，例如:&gt; SELECT id FROM t LIMIT 10000, 10;改为&gt; SELECT id FROM t WHERE id &gt; 10000 LIMIT 10;- 优化UNION。MySQL处理UINON的策略是先创建临时表，然后把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION中都没有很好的处理。此时需要手动将WHERE、LIMIT、ORDER BY等条件字句放到各个子查询中，以便优化器可以充分利用这些条件进行优化。除非确实需要服务器去重，否则一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用了ALL关键字，MySQL也总是将结果放入临时表，然后再读出返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把子查询的结果返回给客户端。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-网络服务如何保证幂等性？&quot;&gt;&lt;a href=&quot;#1-网络服务如何保证幂等性？&quot; class=&quot;headerlink&quot; title=&quot;1. 网络服务如何保证幂等性？&quot;&gt;&lt;/a&gt;1. 网络服务如何保证幂等性？&lt;/h3&gt;&lt;p&gt;幂等性最初来自于数学上的概念，f(x)=
      
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="后台开发" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>畅游Linux(2)-如何愉快的处理文件</title>
    <link href="http://yoursite.com/2019/02/22/%E7%95%85%E6%B8%B8Linux-2-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/02/22/畅游Linux-2-如何愉快的处理文本/</id>
    <published>2019-02-22T09:17:34.000Z</published>
    <updated>2019-03-07T09:19:59.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-grep命令"><a href="#1-grep命令" class="headerlink" title="1.grep命令"></a>1.grep命令</h3><p>grep全称global regular expression print（全局正则表达式输出），常用于文件中特定内容的查找，其命令格式为:</p><blockquote><p>grep [option] pattern file<br>grep命令会把查到的那一行展示出来，并不会改变被查找的文件内容，option常用取值如下：</p><ol><li>-c 只打印匹配的文本行数，不显示内容。</li><li>-i 匹配时忽略大小写。</li><li>-h 当搜索多个文件时，不显示匹配文件前缀名。</li><li>-n 列出所有匹配的行，并显示行号。</li><li>-l 只列出含有匹配行的文件的文件名，不显示匹配内容。</li><li>-v 只显示不匹配的文本行。</li><li>-w 匹配整个单词。</li><li>-x 匹配整个文本行。</li><li>-r 递归搜索，搜索当前目录和子目录。</li><li>-E 支持扩展正则表达式。</li></ol></blockquote><p>下面找几个典型的使用locate查找的例子：</p><ol><li>在多个文件之间查询，查询时忽略大小写<blockquote><p>grep -i “hello world” a.txt b.txt</p></blockquote></li><li>将/etc/passwd中含有root的行打印出来，并展示行号<blockquote><p>grep -n root /etc/passwd</p></blockquote></li><li>将/etc/passwd中不含root的行提取戳来<blockquote><p>grep -v root /etc/passwd</p></blockquote></li><li>将/etc/passwd中不含root和admin的行提取出来<blockquote><p>grep -v root /etc/passwd | grep -v admin</p></blockquote></li><li>递归查找/etc下含有root的文件并展示行号<blockquote><p>grep -rn root /etc<br>要查找的字符串还可以使用通配符，例如：</p></blockquote></li><li>查找/etc/passwd 中以r开头的行并打印<blockquote><p>grep -n “^r” /etc/passwd</p></blockquote></li><li>查找/etc/passwd中包含oo或者et的行<blockquote><p>grep -n “oo|et” /etc/passwd<br>此外，grep还常用来与一些系统常用命令结合，来获取某些特定信息例如：</p></blockquote></li><li>查看系统是否含有game相关的进程<blockquote><p>ps -ef | grep game</p></blockquote></li><li>查看3333端口是否被监听<blockquote><p>netstat -an | grep 3333</p></blockquote></li></ol><h3 id="2-awk命令"><a href="#2-awk命令" class="headerlink" title="2.awk命令"></a>2.awk命令</h3><p>与普通的linux命令不同，awk命令更多情况下被称作一种编程语言。其一般被用作linux/unix下的文本和数据处理。数据可以来自于文件，或者其他命令的输出，它支持用户自定义函数和正则表达式等功能。<br>awk命令基本结构如下：</p><blockquote><p>awk ‘BEGIN{ print “start” } pattern{ commands } END{ print “end” }’ file<br>一个awk命令通常由：BEGIN语句块、使用模式匹配的通用语句块、END语句块三部分组成。这三部分是可选的，任何一个部分都可以不出现在脚本中，脚本通常被单引号或者双引号引用。例如：<br>awk ‘BEGIN{ i=0 } { i++ } END{ print i }’ filename<br>对任意一个awk命令<br>awk ‘BEGIN{ commands } pattern{ commands } END{ commands }’<br>工作流程是：</p><ol><li>执行BEGIN{commands}语句块中的语句。</li><li>从文件或者标准输入(stdin)输入一行，然后执行pattern{commands}语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到所有的文件都被读取完毕。</li><li>当读至输入流末尾时，执行END{commands}语句块。<br>BEGIN语句块：在awk开始从输入流读取文件之前执行，常用与变量初始化，是一个可选的语句块。<br>END语句块：在awk从输入流中读取完所有行之后被执行，可用来打印汇总信息，也是一个可选的语句块。<br>pattern语句块：命令中最重要的部分，也是可选的。如果没有pattern语句块，默认执行{print}打印每一个读取到的行。awk读取每一行时都会执行该语句。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-grep命令&quot;&gt;&lt;a href=&quot;#1-grep命令&quot; class=&quot;headerlink&quot; title=&quot;1.grep命令&quot;&gt;&lt;/a&gt;1.grep命令&lt;/h3&gt;&lt;p&gt;grep全称global regular expression print（全局正则表达式输
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="文件处理" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
      <category term="经验总结" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>畅游Linux(1)-如何愉快的查找文件</title>
    <link href="http://yoursite.com/2019/02/15/%E7%95%85%E6%B8%B8Linux-1-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/02/15/畅游Linux-1-如何愉快的查找文件/</id>
    <published>2019-02-15T07:45:34.000Z</published>
    <updated>2019-02-16T09:08:18.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-find命令"><a href="#1-find命令" class="headerlink" title="1.find命令"></a>1.find命令</h3><p>Linux 中find命令常用来在某个目录下查找目录或者文件，其使用语法规则如下：</p><blockquote><p>find path -option [ -print ] [ -exec -ok command] {}\;<br>其中，-print代表将找到的文件输出到标准输出；-exec和-ok作用类似，找到文件后执行某个命令。不同之处在于，-ok在执行命令之前需要用户确认<br>常用的option命令有：</p><ol><li>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件。</li><li>-amin n : 在过去n分钟内被读取过。</li><li>-anewer file : 比文件file更晚被读取过的文件。</li><li>-atime n : 在过去n天内被读取过的文件。</li><li>-cmin n : 在过去n分钟内被修改过。</li><li>-cnewer file :比文件file更新的文件。</li><li>-ctime n : 在过去n天内被修改过的文件。</li><li>-empty : 空的文件。</li><li>-gid n or -group name :gid是n或是group名称是name。</li><li>-ipath p, -path p : 路径名称符合p的文件ipath会忽略大小写。</li><li>-name name, -iname name : 文件名称符合name的文件。iname会忽略大小写。</li><li>-size n : 文件大小 是n单位，b 代表512位元组的区块，c表示字元数，k表示kilo bytes，w是二个位元组。</li><li>-pid n : process id是n的文件</li><li>-type c : 文件类型是c的文件。(type后面跟的类型还可以是，d:目录，c: 字型装置文件，b: 区块装置文件，p: 具名贮列，f: 一般文件，l: 符号连结，s: socket)</li><li>-perm n : 按照文件权限查找，例如-perm 655</li><li>-prune : 查找时排除某些目录</li><li>-user : 查找某些用户的文件</li><li>-group : 查找某些用户组的文件</li></ol></blockquote><p>下面找几个典型的使用find查找的例子：</p><ol><li>查找目录下所有扩展名为cpp的文件：<blockquote><p>find . -name “*.cpp”</p></blockquote></li><li>查找目录及其子目录下所有最近20天内更新过的文件：<blockquote><p>find . -ctime -20</p></blockquote></li><li>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问：<blockquote><p>find /var/log -type f -mtime +7 -ok rm {} \</p></blockquote></li><li>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：<blockquote><p>find . -type f -perm 644 -exec ls -l {} \</p></blockquote></li><li>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：<blockquote><p>find / -type f -size 0 -exec ls -l {} \</p></blockquote></li><li>在当前目录下查找长度超过10块的文件(一块等于512字节):<blockquote><p>find . -size +10</p></blockquote></li><li>在/apps目录下查找文件，忽略/apps/bin目录(需要注意的是，此处的-o为表达式，当-o前面的语句生效时不执行-o后面的语句)：<blockquote><p>find /apps -name “target” -prune -o -print</p></blockquote></li></ol><h3 id="2-locate命令"><a href="#2-locate命令" class="headerlink" title="2.locate命令"></a>2.locate命令</h3><p>locate命令作用上类似于find -name，使用一般格式如下：</p><blockquote><p>Locate [选择参数] [样式]<br>locate实现方式是在系统中维护一个所有文件及其所在路径的数据库。查找的时候直接在DB中进行查找，所以查找速度非常快，但是缺点也很明显，查找结果比较依赖于数据库的更新速度。如果文件是最近刚建立，在DB没有更新的情况下可能locate查找失败。<br>locate使用的索引数据库一般放在crontab中定时更新，也可以使用updatedb手动更新索引数据库。locate常用的参数有：</p><ol><li>-e 将排除在寻找的范围之外。</li><li>-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</li><li>-q 安静模式，不会显示任何错误讯息。</li><li>-n 至多显示 n个输出。</li><li>-r 使用正规运算式 做寻找的条件。</li><li>-o 指定资料库存的名称。 </li><li>-d 指定资料库的路径</li></ol></blockquote><p>下面找几个典型的使用locate查找的例子：</p><ol><li>忽略大小写查找当前目录下D开头的文件：<blockquote><p>locate -i ./d</p></blockquote></li><li>2.查找/etc目录下以m开头的文件： <blockquote><p>locate /etc/m</p></blockquote></li></ol><h3 id="3-whereis命令"><a href="#3-whereis命令" class="headerlink" title="3.whereis命令"></a>3.whereis命令</h3><p>whereis命令类似于locate，不同之处在于，whereis一般只用于二进制文件(-b)，man帮助文件(-m)以及源码文件(-s)的查找。<br>whereis命令的有点与缺点类似，唯一的区别是whereis一般不支持模糊查找,而locate是可以支持模糊查找的。</p><h3 id="4-which命令"><a href="#4-which命令" class="headerlink" title="4.which命令"></a>4.which命令</h3><p>which命令用于命令的查找，查找路径是系统的PATH目录：</p><blockquote><p>Locate 可执行文件名<br>which 使用的参数有：</p><ol><li>-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li><li>-p 与-n参数相同，但此处的包括了文件的路径。</li><li>-w 指定输出时栏位的宽度。</li></ol></blockquote><p>例如要查找ls命令，可以使用</p><blockquote><p>which ls</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-find命令&quot;&gt;&lt;a href=&quot;#1-find命令&quot; class=&quot;headerlink&quot; title=&quot;1.find命令&quot;&gt;&lt;/a&gt;1.find命令&lt;/h3&gt;&lt;p&gt;Linux 中find命令常用来在某个目录下查找目录或者文件，其使用语法规则如下：&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="经验总结" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>简单理解正向代理，反向代理与负载均衡</title>
    <link href="http://yoursite.com/2019/02/13/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/02/13/简单理解正向代理，反向代理与负载均衡/</id>
    <published>2019-02-13T03:08:00.000Z</published>
    <updated>2019-02-13T06:49:04.355Z</updated>
    
    <content type="html"><![CDATA[<p>正向代理与反向代理是相对的一组概念，简单来说，正向代理隐藏了客户端，而反向代理则隐藏了服务端。</p><p><a href="https://postimg.cc/wtc28nbf" target="_blank" rel="noopener"><img src="https://i.postimg.cc/Gp65YCPC/3.png" alt="正向代理与反向代理"></a></p><p>正向代理常见的应用例如，VPN。如果在国内是没有办法直接访问Google，Youtube等网站。那我们就可以在国外买一台服务器搭一个VPN，然后通过该服务器访问国外的网站。这台VPN服务器充当的就是正向代理的角色。</p><p>而反向代理通常对开发来说更熟悉一些。Google的服务器可能有成千上万台，当我们访问Google官网的时候，代理服务器请将我们的请求转发到某一台服务器上，此时的代理就是反向代理。</p><p>负载均衡的主要目标就是将请求分发到几台服务器上来环境单台服务器的压力，提高服务质量。反向代理是实现负载均衡的实现手段，但反向代理的作用又不仅限于负载均衡。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正向代理与反向代理是相对的一组概念，简单来说，正向代理隐藏了客户端，而反向代理则隐藏了服务端。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://postimg.cc/wtc28nbf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;htt
      
    
    </summary>
    
    
      <category term="正向代理" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="反向代理" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2019&#39;s todo list</title>
    <link href="http://yoursite.com/2019/02/12/2019-s-todo-list/"/>
    <id>http://yoursite.com/2019/02/12/2019-s-todo-list/</id>
    <published>2019-02-12T07:01:49.000Z</published>
    <updated>2020-01-29T12:33:18.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h4 id="接入层"><a href="#接入层" class="headerlink" title="接入层"></a>接入层</h4><pre><code>- 负载均衡- 流量控制- 降级- 熔断- 防雪崩- ...</code></pre><h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h4><pre><code>- 可扩展 (水平/垂直)- 隔离- 解耦- RPC (dubbo/thrift/grpc)- 连接池- 消息队列 (RocketMQ/RabbitMQ/Kafka/ZeroMQ/redis)- 延迟加载- 数据预读- 轮询通知- 事件系统- 模块化</code></pre><h4 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h4><pre><code>- 缓存 (缓存穿透/缓存雪崩/缓存击穿)- 一致性(CAP/分布式锁/一致性算法/幂等)- 主从架构- 去中心化架构- 唯一ID生成- 一致性Hash- 数据库扩展</code></pre><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><pre><code>- 服务注册与发现 (名字服务)- 服务路由- 服务网关- 配置中心</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><pre><code>- 监控系统- 日志系统- 测试- 平滑启动- 异地多活- docker</code></pre><h2 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h2><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><pre><code>- 二叉树- 红黑树- 平衡二叉树- B-树- B+树</code></pre><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><pre><code>- 快排- 冒泡- 交换- 桶- 堆...**待续...**</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式系统&quot;&gt;&lt;a href=&quot;#分布式系统&quot; class=&quot;headerlink&quot; title=&quot;分布式系统&quot;&gt;&lt;/a&gt;分布式系统&lt;/h2&gt;&lt;h4 id=&quot;接入层&quot;&gt;&lt;a href=&quot;#接入层&quot; class=&quot;headerlink&quot; title=&quot;接入层&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="TODO" scheme="http://yoursite.com/tags/TODO/"/>
    
  </entry>
  
</feed>
